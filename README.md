# Compiling Parallel Symbolic Execution with Continuations (Artifact)

This document is the instruction for the ICSE 2023 artifact evaluation for
paper *Compiling Parallel Symbolic Execution with Continuations*.
The artifact implements the symbolic-execution compiler
[GenSym](https://github.com/Generative-Program-Analysis/GenSym) and provides
instructions and benchmarks to reproduce the empirical experiments reported in
the paper.

This document is also available online at https://github.com/Generative-Program-Analysis/icse23-artifact-evaluation.

Authors: Guannan Wei, Songlin Jia, Ruiqi Gao, Haotian Deng, Shangyin Tan, Oliver Braƒçevac, Tiark Rompf

TODO: TOC

## 1. Obtaining the Artifact

The artifact is available as a pre-built Docker image, which has all
dependencies and third-party tools installed.

To obtain the Docker image (you may need root privilege to run `docker`):

```
$ docker pull guannanwei/gensym:icse23
```

### Start the Docker Container

Then to instantiate the Docker image, run the following command:

```
docker run --name <container_name> --ulimit='stack=-1:-1' -it guannanwei/gensym:icse23 bash
```

Then we should be able to see the prompt of `bash`.
All experiments are conducted within the Docker container.

In case there are up-stream changes of the artifact, once the container is
started you can run the following command:
```
# cd /icse23
# bash sync.sh
```
to pull those changes.

Once running inside the Docker, you can also find this document
at `/icse23/icse23-artifact-evaluation/README.md`.

### Build the Docker Image

The scripts used to build the Docker image can be found from
`/icse23/GenSym/docker-image/Dockerfile` and
`/icse23/GenSym/docker-image/init_script.sh`.
Following these scripts, one can rebuild the Docker image from scratch by
running given a tag name:
```
$ cd /icse23/GenSym/docker-image
$ docker build -t <image-tag-name> .
```
It is *not* necessary for the artifact evaluation to rebuild the image,
but might be useful for anyone who would like to reuse or deploy GenSym.

## 2. Artifact Overview

The Docker image runs Ubuntu 20.04 and contains [GenSym at the `icse23` branch](#),
the [LLSC at the `fse21demo` branch](#), and
[KLEE of version 2.3](https://github.com/klee/klee/tree/v2.3).
LLSC and KLEE are two similar symbolic execution tools that are compared
with GenSym in the paper.

GenSym itself is written in Scala as a staged symbolic interpreter of
LLVM IR. Given an LLVM IR program, GenSym generates a C++ program that embeds
the parallel symbolic execution semantics of the input program.
Compiling and running this C++ program then perform symbolic execution
and test case generation.

LLSC is the predecessor of GenSym. They are similar in that they both use
multi-stage programming and partial evaluation to compile LLVM IR symbolically.
However, LLSC does not generate code in continuation-passing style, which leads
to unsatisfying parallel execution performance and limited capabilities of using
heuristics.

KLEE is a state-of-the-art symbolic execution tool implemented as a interpreter,
in contrast to compilation-based tool such as GenSym.

### Software Dependencies

The GenSym compiler relies on the Lightweight Modular Staging (LMS) framework
(`/icse23/GenSym/third-party/lms-clean`). Other Scala dependencies and their
versions are specified in `/icse23/GenSym/build.sbt`.
GenSym's backend uses a few C++ data structures libraries, including
[immer](https://github.com/arximboldi/immer) and [parallel-hashmap](https://github.com/greg7mdp/parallel-hashmap) (exact version dependencies specified in `.gitmodules`).

Other system-wide installed third-party libraries and dependencies used
in the artifact include

- Z3 4.8.12
- STP 2.3.3
- g++ 9.10
- clang/clang++/LLVM 11
- Java Virtual Machine 11
- Scala 2.12
- sbt

### Directory Structure

We briefly describe the organization of GenSym's code base, located at `/icse23/GenSym` of the Docker image:

- `benchmarks` contains the C source code and makefiles to generate LLVM IRs of them
- `docker-image` contains scripts to build the docker image
- `grammar` contains the ANTLR grammar definitions, which is used to generate the parser of textual LLVM IR programs
- `runtime` contains the source of GenSym's runtime, which are currently implemented as C++ headers
- `third-party` contains libraries that are used by GenSym's runtime, including data structures and SMT solvers
- `src/main` is the root directory of GenSym's front-end source code
  - `src/main/java` contains the LLVM IR parser generated by ANTLR
  - `src/main/scala/llvm` contains the Scala adapter of the parser generated by ANTLR
  - `src/main/scala/lms` contains customization of the Lightweight Modular Staging framework as well as GenSym's code generation facility
  - `src/main/scala/structure` contains algebraic structure definitions that are used to help high-level functional programming
  - `src/main/scala/utils` contains utilities
  - `src/main/scala/gensym` is the main directory of GenSym's implementation
    - GenSym implements a few variants staged symbolic interpreters (i.e. compilers), which are contained in `src/main/scala/engines`. The default and most mature compile is `src/main/scala/engines/ImpCPSEngine.scala` that generates CPS code and uses in-place update when possible.
- `src/test` contains testing infrastructure that are used in Github CI

## 3. Hardware Requirements

The artifact evaluation involves running parallel symbolic execution, therefore we
recommend using a machine with at least 16 physical cores and 32GB of memory.
The artifact only supports x86-64 architecture running Linux-based operating
systems.

To obtain accurate performance numbers and minimize interference, the evaluation
process also requires exclusive use of the machine.

Note: The experiment result reported in the paper is obtained from a machine
with 96 physical cores (192 physical+logical cores) and 3TB memory (although we
will not use that much memory). Different hardware environment may result in
numbers with different characteristics, but we expect the trend/ratio to be
similar.


## 4. Kick-the-Tires

**Expected Time: 15 minutes**

In this Kick-the-Tires step, we make a basic sanity check of the whole compilation pipeline.
We use a simple branching program as example and explain the pipeline.

The first preparation step is to generate GenSym's external models.
These models simulate symbolic behaviors of external functions, such as
the POSIX file system.
GenSym defines models for external functions in a Scala DSL, which will be
generated to C++ functions that can be used together with the compiled
application code.
To do this, we start an interactive `sbt` session by running
(`start_sbt` sets necessary parameters for JVM and invokes `sbt`):

```
# cd /icse23/GenSym
# ./start_sbt
```

Then we run the following command in the `sbt` session to generate models for external functions
(**this is also necessary for reproducing experiments RQ{1-6}**):

```
sbt:GenSym> runMain gensym.GenerateExternal
```

The first time running `sbt` downloads dependencies specified in `build.sbt` and
compiles the Scala code to JVM bytecode, which may take a few minutes.
After printing some compilation log, we should see `[success]` in the output.
(TODO: disable logging)
This generates a C++ file `/icse23/GenSym/headers/gensym/external.hpp`.

Next, we can use GenSym to compile a simple example program. We use a C program,
which is stored in `/icse23/GenSym/benchmarks/llvm/branch.c`:

```
int f(int x, int y) {
  if (x <= 0 || y <= 0) return -1;
  if (x * x + y * y == 25) {
    return 1;
  }
  return 0;
}
```

Its LLVM IR file can be found in `/icse23/GenSym/benchmarks/llvm/branch.ll`.
We have mechanized this kick-the-tire compilation process as a test case. We
can run the following command in `sbt` to use GenSym to compile:

```
sbt:GenSym> testOnly icse23.KickTheTires
```

This step invokes GenSym to (1) compile the LLVM IR input to C++ code
for symbolic execution, (3) compile the C++ code to an executable, and
(4) run the executable to generate test cases.
Symbolically executing this program discovers 4 paths, and we expect to see the
following output from `sbt` at the end:

```
[info] All tests passed.
```

This signals the success of the kick-the-tires compilation process.
The generated C++ program and tests are located in
`/icse23/GenSym/gs_gen/ImpCPSGS_branch1` for further inspection.

## 4. Benchmarks Description

The paper uses two groups of benchmarks: (1) algorithm programs with finite
numbers of paths, and (2) a subset of GNU Coreutils (v8.32) programs that have interaction
with OS file system and command line interface.

We use the algorithm benchmarks in Table I, whose C source code and LLVM IR can
be found in `/icse23/GenSym/benchmarks/icse23/algorithms`.

We use the Coreutils benchmarks in the rest of experiments, including Table {II,
III, IV, V}.
Their LLVM IR can be found in `/icse23/GenSym/benchmarks/icse23/coreutils`.
The C source code of Coreutils are not included in the artifact, but can
be found publiclly at `git://git.sv.gnu.org/coreutils`.
The generation of Coreutils LLVM IR from their C source code is not
part of the artifact, but can be found in a [separate document](https://github.com/Generative-Program-Analysis/coreutils-testing-instruction) we
prepared.

Further more, these Coreutils benchmarks can be used with different input
configurations. The paper uses two configurations: (1) *short-running*
configurations that have smaller number of symbolic inputs and can be
symbolically executed in a few minutes, and (2) *long-running*
configurations that have more number of symbolic inputs and take much
longer time to test.

Both GenSym and KLEE can finish the short-running configuration benchmarks,
and they explore the same set of paths. Therefore we can compare the performance
based on the same workload.
The long-running configuration benchmarks are used to evaluate the scalability.
Both engines time out at 1 hour, and then we can compare the throughput,
i.e. the number of paths they explore per second (assuming that paths are homogeneous).

More specifically, the long-running configuration of Coreutils programs
are used in the *lower part* of Table II for RQ2.
All other experiments including the upper part of Table II, Table III, Table IV, and Table V
all uses the short-running configuration.

## 5. Evaluation Instructions

### RQ1

**Expected Time: 30 minutes**

This experiment answers RQ1 and generates Table I of the paper.  We will first
examine the benchmarks, and then run the experiment using LLSC, GenSym, and
KLEE, and finally generate the digested results.

**Examining Benchmarks**

The set of benchmarks for RQ1 are located in `/icse23/GenSym/benchmarks/icse23/algorithms`.
Both C source code and LLVM IR of them are already included.
The `.ll` files are used by GenSym and LLSC, and `.bc` files are used for KLEE, since
they link with different engine-specific APIs.
A `Makefile` is accompanied with these benchmarks, so a suer can modify the program
and produce different test cases using the same process.

- To show the LOC of C source code ("C LOC" column in Table I):

```
# cd /icse23/GenSym/benchmarks/icse23/algorithms
# cloc --by-file *.c
```

- To show the LOC of LLVM IR code ("LLVM LOC" column in Table I):

```
# wc -l *.ll
```

- The number of symbolic inputs (i.e. the "#Sym Args" column in Table I) are
annotated in the C source file. Using `bubblesort.c` as an example, the program
initializes `SIZE` symbolic variables using engine-specific APIs, which is 6 in
this case.

- The number of paths of each benchmark program (i.e. the "#Paths" column in Table I)
is produced by running the program with symbolic execution, which is the next step.

**Running LLSC**

```
# cd /icse23/icse23-artifact-evaluation/table1
# bash run_llsc.sh
```
This steps compiles those benchmarks with LLSC, which generates code under
`/icse23/llsc/dev-clean/llsc_gen`, and further generate executable files.
The script will also invoke the executable and perform the symbolic execution.
The execution log and raw timing data are stored in
`/icse23/icse23-artifact-evaluation/table1/results`.

**Running GenSym**

```
# cd /icse23/icse23-artifact-evaluation/table1
# bash run_gensym.sh
```

**Running KLEE**

```
# cd /icse23/icse23-artifact-evaluation/table1
# bash run_klee.sh
```

**Generating Results**

```
# cd /icse23/icse23-artifact-evaluation/table1
# bash show_table1.py
```

### RQ2

**Expected Time:**

table 2

### RQ3

**Expected Time:**

table 3

numactl

### RQ4

**Expected Time:**

table 4

### RQ5

**Expected Time:**

table 5

### RQ6
**Expected Time:**

table 5

## 6. Try Your Own Programs

### Use GenSym's Interface

It is possible to use GenSym's interface to compile your own programs.
One way is to run GenSym's main function in `sbt`:

```
```

### The Structure of Generated Files